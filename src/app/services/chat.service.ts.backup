import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '../../environments/environment';
import { DemoService } from './demo.service';

export interface ChatRequest {
  query: string;
}

export interface ChartData {
  render_mode: 'frontend' | 'backend';
  chart_type?: string;
  chart_image?: string; // base64 encoded image for backend mode
  chart_config?: {
    labels?: string[];
    datasets?: ChartDataset[];
    options?: any;
    // Backend chart specific properties
    image_data?: string;
    alt_text?: string;
    title?: string;
  };
}

export interface ChartDataset {
  label: string;
  data: number[];
  backgroundColor?: string | string[];
  borderColor?: string | string[];
  borderWidth?: number;
  fill?: boolean;
  tension?: number; // For line charts
  yAxisID?: string; // For dual y-axis charts
}

export interface ChatResponse {
  status: string;
  message: string | null;
  sql_query: string;
  insight: string;
  data: any[];
  chart_data?: ChartData;
}

export interface ChatMessage {
  id: string;
  type: 'user' | 'bot';
  content: string;
  timestamp: Date;
  response?: ChatResponse;
  isLoading?: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class ChatService {
  private readonly apiUrl = environment.apiUrl;
  private demoMode = false; // Set to true to use demo mode without backend by default

  constructor(
    private http: HttpClient,
    private demoService: DemoService
  ) { }

  setDemoMode(enabled: boolean): void {
    this.demoMode = enabled;
  }

  isDemoMode(): boolean {
    return this.demoMode;
  }

  getApiUrl(): string {
    return this.apiUrl;
  }
  sendMessage(query: string): Observable<ChatResponse> {
    if (this.demoMode) {
      return this.demoService.processQuestion(query);
    }

    const payload: ChatRequest = { query };
    
    return this.http.post<any>(`${this.apiUrl}`, {query})      .pipe(
        map(response => this.parseApiResponse(response)),
        catchError(this.handleError)
      );
  }

  public parseApiResponse(response: any): ChatResponse {
    // Create a copy of the response to avoid mutating the original
    const parsedResponse: ChatResponse = { ...response };    // Handle chart_data - it can come as a string (JSON) or already as an object
    if (response.chart_data) {
      let chartData = response.chart_data;
        // Only try to parse if it's actually a string      if (typeof response.chart_data === 'string') {
        try {
          // First try standard JSON.parse
          chartData = JSON.parse(response.chart_data);
        } catch (error) {
          // If standard parsing fails, try to fix common malformed JSON issues
          try {
            console.log('Standard JSON parsing failed, attempting to fix malformed JSON...');
            const fixedJsonString = this.fixMalformedJson(response.chart_data);
            chartData = JSON.parse(fixedJsonString);
            console.log('Successfully parsed fixed JSON');
          } catch (secondError) {
            console.warn('Failed to parse chart_data JSON string even after fixing:', secondError);
            console.warn('Original chart_data value:', response.chart_data);
            
            // Last resort: try to reconstruct chart data from the raw API data
            const reconstructedChart = this.reconstructChartFromApiData(response);
            if (reconstructedChart) {
              console.log('Successfully reconstructed chart data from raw API response');
              chartData = reconstructedChart;
            } else {
              // If parsing fails completely, remove chart_data to prevent rendering errors
              delete parsedResponse.chart_data;
              chartData = null;
            }
          }
        }
      }
      // If it's already an object, use it directly
      else if (typeof response.chart_data === 'object') {
        chartData = response.chart_data;
      }
      
      // If we have valid chart data (either parsed or already an object), validate and normalize it
      if (chartData && this.isValidChartData(chartData)) {
        // Normalize property names for Chart.js compatibility
        parsedResponse.chart_data = this.normalizeChartDataProperties(chartData);
      } else if (chartData) {
        console.warn('chart_data does not match expected structure:', chartData);
        delete parsedResponse.chart_data;
      }
    }

    // Ensure data is parsed if it's a string (some APIs might return it as a string)
    if (response.data && typeof response.data === 'string') {
      try {
        parsedResponse.data = JSON.parse(response.data);
      } catch (error) {
        console.warn('Failed to parse data JSON string:', error);
        // Keep original data if parsing fails
        parsedResponse.data = response.data;
      }
    }

    // Ensure data is an array
    if (!Array.isArray(parsedResponse.data)) {
      parsedResponse.data = [];
    }

    return parsedResponse;
  }

  private isValidChartData(data: any): boolean {
    // Basic validation for ChartData structure
    if (!data || typeof data !== 'object') {
      return false;
    }

    // Check for required render_mode
    if (!data.render_mode || (data.render_mode !== 'frontend' && data.render_mode !== 'backend')) {
      return false;
    }

    // Validate frontend chart structure
    if (data.render_mode === 'frontend') {
      const validChartTypes = ['pie', 'line', 'bar', 'stacked_bar'];
      if (!data.chart_type || !validChartTypes.includes(data.chart_type)) {
        return false;
      }
      
      // Should have chart_config for frontend charts
      if (!data.chart_config) {
        return false;
      }
    }

    // Validate backend chart structure
    if (data.render_mode === 'backend') {
      if (!data.chart_config || !data.chart_config.image_data) {
        return false;
      }
    }    return true;
  }

  private normalizeChartDataProperties(data: ChartData): ChartData {
    // Create a deep copy to avoid mutating the original
    const normalized = JSON.parse(JSON.stringify(data));

    // For frontend charts, normalize the dataset properties
    if (normalized.render_mode === 'frontend' && normalized.chart_config && normalized.chart_config.datasets) {
      normalized.chart_config.datasets = normalized.chart_config.datasets.map((dataset: any) => {
        // Normalize property names from API format to Chart.js format
        const normalizedDataset = { ...dataset };
        
        // Map backgroundcolor -> backgroundColor
        if (dataset.backgroundcolor) {
          normalizedDataset.backgroundColor = dataset.backgroundcolor;
          delete normalizedDataset.backgroundcolor;
        }
        
        // Map bordercolor -> borderColor
        if (dataset.bordercolor) {
          normalizedDataset.borderColor = dataset.bordercolor;
          delete normalizedDataset.bordercolor;
        }
        
        // Map borderwidth -> borderWidth
        if (dataset.borderwidth) {
          normalizedDataset.borderWidth = dataset.borderwidth;
          delete normalizedDataset.borderwidth;
        }
        
        // Map pointbackgroundcolor -> pointBackgroundColor
        if (dataset.pointbackgroundcolor) {
          normalizedDataset.pointBackgroundColor = dataset.pointbackgroundcolor;
          delete normalizedDataset.pointbackgroundcolor;
        }
        
        // Map pointbordercolor -> pointBorderColor
        if (dataset.pointbordercolor) {
          normalizedDataset.pointBorderColor = dataset.pointbordercolor;
          delete normalizedDataset.pointbordercolor;
        }
        
        // Map pointborderwidth -> pointBorderWidth
        if (dataset.pointborderwidth) {
          normalizedDataset.pointBorderWidth = dataset.pointborderwidth;
          delete normalizedDataset.pointborderwidth;
        }
        
        return normalizedDataset;
      });
    }    return normalized;
  }  private fixMalformedJson(malformedJson: string): string {
    console.log('Attempting to fix malformed JSON...');
    
    // Remove newlines and extra spaces for easier processing
    let fixed = malformedJson.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    
    // Fix unquoted property names - find patterns like "word:" and convert to "word":
    fixed = fixed.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
    
    // Fix single quotes to double quotes for string values
    // This is tricky because we need to avoid replacing single quotes inside strings
    // First, let's handle simple cases: 'value' -> "value"
    fixed = fixed.replace(/:\s*'([^']*?)'/g, ': "$1"');
    
    // Handle array elements with single quotes
    fixed = fixed.replace(/\[\s*'([^']*?)'/g, '["$1"');
    fixed = fixed.replace(/,\s*'([^']*?)'/g, ', "$1"');
    fixed = fixed.replace(/'([^']*?)'\s*\]/g, '"$1"]');
    
    // Handle truncated data arrays - this is more comprehensive now
    // Look for patterns like: , 31302. or , 31302 at the end
    const truncatedPatterns = [
      /,\s*(\d+\.)\s*$/,           // ends with "31302."
      /,\s*(\d+)\s*$/,             // ends with "31302"
      /,\s*(\d+\.\d*)\s*$/,        // ends with "31302.80" (partial decimal)
      /\[\s*(\d+\.)\s*$/,          // array starts with truncated number
      /\[\s*(\d+\.\d*)\s*$/        // array starts with partial decimal
    ];
    
    let wasTruncated = false;
    for (const pattern of truncatedPatterns) {
      if (pattern.test(fixed)) {
        console.log('Found truncated number pattern:', pattern);
        // Remove the truncated number
        fixed = fixed.replace(pattern, '');
        wasTruncated = true;
        break;
      }
    }
    
    // If we found truncation, ensure proper closure
    if (wasTruncated) {
      // Remove any trailing comma that might be left
      fixed = fixed.replace(/,\s*$/, '');
      
      // Count open brackets vs close brackets to determine how many we need to close
      const openBrackets = (fixed.match(/\[/g) || []).length;
      const closeBrackets = (fixed.match(/\]/g) || []).length;
      const openBraces = (fixed.match(/\{/g) || []).length;
      const closeBraces = (fixed.match(/\}/g) || []).length;
      
      console.log(`Brackets - Open: ${openBrackets}, Close: ${closeBrackets}`);
      console.log(`Braces - Open: ${openBraces}, Close: ${closeBraces}`);
      
      // Close missing array brackets
      for (let i = 0; i < (openBrackets - closeBrackets); i++) {
        fixed += ']';
      }
      
      // Close missing object braces  
      for (let i = 0; i < (openBraces - closeBraces); i++) {
        fixed += '}';
      }
    }
    
    // Handle trailing commas in arrays/objects
    fixed = fixed.replace(/,(\s*[\]}])/g, '$1');
    
    // Handle empty array elements (double commas)
    fixed = fixed.replace(/,\s*,/g, ',');
    
    console.log('Fixed JSON string:', fixed);
    return fixed;
  }

  // Test method to verify chart_data parsing - can be removed in production
  public testChartDataParsing(apiResponseWithStringChartData: any): ChatResponse {
    console.log('Testing chart_data parsing...');
    console.log('Input (string chart_data):', apiResponseWithStringChartData);
    
    const parsed = this.parseApiResponse(apiResponseWithStringChartData);
    
    console.log('Output (parsed chart_data):', parsed);
    console.log('chart_data type:', typeof parsed.chart_data);
    
    return parsed;
  }

  /**
   * Reconstruct chart data from raw API data when JSON parsing fails
   */
  private reconstructChartFromApiData(response: any): ChartData | null {
    try {
      // Check if we have the raw data array to reconstruct from
      if (!response.data || !Array.isArray(response.data) || response.data.length === 0) {
        return null;
      }

      console.log('Attempting to reconstruct chart from raw API data...');
      
      // Extract common patterns from the raw data
      const dataArray = response.data;
      const firstRecord = dataArray[0];
      
      // Try to identify time-series data patterns
      if (firstRecord.Year && firstRecord.Month && firstRecord.MonthName) {
        // Monthly sales data pattern
        const labels = dataArray.map((record: any) => {
          const monthYear = `${record.MonthName} ${record.Year}`;
          return monthYear;
        });
        
        const values = dataArray.map((record: any) => {
          // Try different possible value field names
          return record.TotalSales || record.Sales || record.Value || record.Amount || 0;
        });
        
        return {
          render_mode: 'frontend',
          chart_type: 'line',
          chart_config: {
            labels: labels,
            datasets: [{
              label: 'Sales Data',
              data: values
            }]
          }
        };
      }
      
      // Try to identify other common patterns
      // Pattern: objects with name/value pairs
      const keys = Object.keys(firstRecord);
      if (keys.length >= 2) {
        // Look for text field (for labels) and number field (for data)
        const textField = keys.find(key => typeof firstRecord[key] === 'string');
        const numberField = keys.find(key => typeof firstRecord[key] === 'number');
        
        if (textField && numberField) {
          const labels = dataArray.map((record: any) => record[textField]);
          const values = dataArray.map((record: any) => record[numberField]);
          
          return {
            render_mode: 'frontend',
            chart_type: 'line',
            chart_config: {
              labels: labels,
              datasets: [{
                label: numberField.replace(/([A-Z])/g, ' $1').trim(), // Convert camelCase to readable
                data: values
              }]
            }
          };
        }
      }
      
      console.log('Could not determine data pattern for reconstruction');
      return null;
      
    } catch (error) {
      console.warn('Failed to reconstruct chart data:', error);
      return null;
    }
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    let errorMessage = 'An unknown error occurred';
    
    if (error.error instanceof ErrorEvent) {
      // Client-side error
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // Server-side error
      errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
    }
    
    if (environment.enableDebugLogging) {
      console.error('Chat service error:', errorMessage);
    }
    return throwError(() => new Error(errorMessage));
  }
}
